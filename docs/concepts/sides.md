마인크래프트의 사이드
===================

마인크래프트 모드를 개발하면서 숙지해야 할 매우 중요한 개념은 "클라이언트 사이드" 와 "서버 사이드" 입니다. 이에 대해 많은 사람들이 오해하고 있고, 이로 인해 게임을 튕기게 하진 않지만 예기치 못한 동작을 하도록 만들 수 있는 해결하기 까다로운 오류가 발생할 수 있습니다.

사이드의 종류들
------------------------

누군가 "클라이언트" 또는 "서버" 에 대해 이야기할 때,  꽤나 직관적으로 게임의 무슨 부분을 뜻하는지 알 수 있습니다. 따지고 보면 클라이언트는 유저와 상호작용 하는 것이고 서버는 멀티 플레이를 위해 여러 유저가 접속하는 것이지요. 간단하네요, 안그런가요?

사실은 그렇지 않습니다. 사이드를 구분하는데 모호한 점이 있을 수 있는데, 그렇기에 여기 확실하게 "클라이언트" 또는 "서버" 가 가지는 4가지 의미를 정리해 놓았습니다:

* 물리 클라이언트 - *물리 클라이언트*는 마인크래프트를 런처로 실행하였을때 켜지는 프로그램 전체를 뜻합니다. 이는 모든 스레드, 프로세스, 그래픽을 표시하는 상호 작용 가능한 생명주기 동안 실행되는 서비스들을 포함합니다.
* 물리 서버 - 전용 서버라고 불리기도 합니다. *물리 서버*는 아무 종류의 "minecraft_server.jar" 을 실행하면 켜지는, 플레이 가능한 GUI 를 표시하지 않는 프로그램 전체를 뜻합니다.
* 논리 서버 - *논리 서버*는 게임의 논리 연산을 수행하는 것입니다: 몬스터 생성, 날씨 조절, 인벤토리 갱신, 채력 관리, 몬스터의 행동 등이 있습니다. 논리 서버는 물리 서버에 존재하나, 물리 클라이언트에 논리 클라이언트와 같이 존재할 수도 있습니다. 싱글 플레이 월드에는 `Server Thread` 에 논리 서버가 언제나 실행됩니다.
* 논리 클라이언트 - *논리 클라이언트*는 플레이어의 입력을 받고 논리 서버로 전달하는 것입니다. 또, 논리 서버로 부터 정보를 받아 플레이어에게 그래픽을 활용해 표시하기도 합니다. 논리 클라이언트는 `Render Thread` 에서 실행됩니다만, 오디오나 청크 배칭 등과 같은 작업들을 처리하기 위해 추가적인 스레드가 더 실행됩니다.

마인크래프트 포지에서는 물리 사이드를 `Dist` 열거형을 사용해 대표합니다, 논리 사이드는 `LogicalSide` 열거형을 사용하여 대표합니다.

사이드별 연산 수행하기
-----------------------------------

### `Level#isClientSide`

이 boolean 필드는 사이드를 확인하는 방법중 가장 자주 쓰입니다. `Level` 객체에 이 메서드를 사용하여 레벨이 속하는 논리 사이드를 확인할 수 있습니다. 이 필드의 값이 `true` 라면 그 레벨은 논리 클라이언트에서 실행되고 있다는 것이고, `false` 를 반환하면 논리 서버에서 실행되고 있는 것입니다. 그러니 물리 서버에서는 늘 `false` 만 반환합니다. 그렇지만 물리 클라이언트에 포함된 논리 서버 또한 `false` 를 반환하기 때문에, 이 메서드가 `false` 를 반환한다고 해서 해당 레벨이 물리 서버에서 실행되고 있다고 짐작하시면 안됩니다.

이 필드를 사용해서 논리 연산이나 게임 메카닉을 처리해야 할지를 결정하도록 하세요. 예를 들어, 플레이어가 블록을 클릭할 때마다 피해를 주고 싶다면, 또는 기계를 사용해 흙을 다이아몬드로 가공하고 싶다면, `#isClientSide` 가 `false` 임을 먼저 확인한 이후 논리 연산을 수행해야 합니다. 논리 연산을 논리 클라이언트에서 수행하면, 운이 좋은 경우엔 비동기화(유령 엔티티, 정확하지 않은 스탯 등)가 일어날 수 있고, 그렇지 않다면 게임이 튕깁니다.

이 필드에 접근할 수 있다면 사용하도록 하세요. `DistExecutor` 를 제외하면, 이거 말고 다른 방법으로 사이드를 확인할 필요가 거의 없습니다.

### `DistExecutor`

서버와 클라이언트가 동일한 모드 jar 파일을 사용한다는 것과, 클라이언트와 서버가 아예 다른 jar 파일로 구분된다는 것을 고려해 보면, 모드가 어떻게 하나의 물리 사이드에만 존재하는 코드를 사용하는지 의문점이 생깁니다. `net.minecraft.client` 패키지에 들어있는 코드들은 물리 클라이언트에만 존재합니다. 만약 이 코드들을 어떻게든 참조하는 클래스를 작성하시면, 그 코드들이 없는 환경에서 그 클래스가 불러와질 때 게임이 튕깁니다. 초보분들이 많이 하시는 실수가 `Minecraft.getInstance().<무언가>` 를 블록이나 블록 엔티티에서 사용하는 것인데, 이는 그 클래스가 불러와지는 그 순간 게임이 튕길 것입니다.

이를 해결하기 위해 FML 에선 `DistExecutor` 를 제공합니다. 이는 물리 사이드에 따라 다른 메서드를 실행하거나, 아예 한쪽 사이드에서만 실행될 코드를 작성할 수 있는 방법을 제공합니다.

!!! note
숙지하셔야 할 점은 FML 은 **논리** 사이드를 이용해 언제 코드를 실행할지를 결정한다는 것입니다. 싱글 플레이 월드(논리 서버와 논리 클라이언트가 있는 물리 클라이언트) 에서는 `Dist.CLIENT` 가 사용됩니다!

`DistExecutor` 는 메서드를 호출할 `Supplier` 를 전달받는 것으로 작동하는데, 이는 [`invokedynamic` JVM 명령][invokedynamic]을 사용하여 클래스 로딩을 막아, 런타임 도중 존재하지 않는 클래스를 불러오려고 시도하는 것을 방지합니다. 이때 호출될 메서드는 정적 메서드이어야 하며 다른 클래스에 정의되어 있어야 합니다. 만약 해당 정적 메서드가 받는 인자가 없다면, `Supplier` 를 전달하기 보단 메서드 레퍼런스를 사용하셔야 합니다.

`DistExecutor` 에는 대표적으로 2개의 메서드가 있는데: `#runWhenOn` 과 `#callWhenOn` 입니다. 이 메서드들은 전달받은 메서드를 실행할 물리 사이드와, 실행될 메서드들을 받습니다. `runWhenOn` 은 결과를 반환하지 않으며, `callWhenOn` 은 결과를 반환합니다. 이때 `callWhenOn` 은 물리 사이드에 따라 null 을 반환할 수도 있습니다.

또, 이 두 메서드들은 `#safe*` 와 `#unsafe*` 로 다시 나뉘는데, 이 둘의 차이점은 개발 환경에서의 기능 차이입니다, `#safe*` 는 전달된 람다가 다른 메서드에 정의된 메서드 레퍼런스인지 확인하는 것입니다, 만약 그렇지 않다면 예외를 발생시킵니다. 해당 검사는 개발 환경에서만 진행되기 때문에 릴리즈 환경에서는 `#safe*` 와 `#unsafe*` 는 기능상 동일합니다.

```java
// 클라이언트 전용 클래스속 어딘가: ExampleClass
public static void unsafeRunMethodExample(Object param1, Object param2) {
  // ...
}
public static Object safeCallMethodExample() {
  // ...
}
// 공용 클래스 어딘가
DistExecutor.unsafeRunWhenOn(Dist.CLIENT, () -> ExampleClass.unsafeRunMethodExample(var1, var2));
DistExecutor.safeCallWhenOn(Dist.CLIENT, () -> ExampleClass::safeCallMethodExample);
```
!!! warning
    Java 9, 또는 이후 버전은 `invokedynamic` 명령이 변경되어 `DistExecutor` 의 `#safe*` 가 개발 환경에서 더 이상 정상적으로 동작하지 않습니다, 그 대신 `BootstrapMethodError` 예외를 발생시킵니다. 그러니 `#unsafe*` 또는 [`FMLEnvironment#dist`][dist] 를 대신 사용하세요. ([해당 이슈 페이지][DistExecutor이슈페이지])

### 스레드 그룹

만약 `Thread.currentThread().getTHreadGroup() == SidedThreadGroups.Server` 가 참이라면 그 스레드는 논리 서버를 실행하고 있을 가능성이 큽니다. 그렇지 않다면 논리 클라이언트를 실행할 가능성이 큽니다. 이는 `Level` 객체에 접근할 수 없을때 **논리** 사이드를 확인하는데 유용합니다. 하지만 이는 확실하게 확인하는 것이 아닌 현재 실행중인 스레드의 그룹을 비교하여 짐작하는 것이기 때문에 가능하면 사용하시지 않는 것을 권장드립니다. 대신 `Level#isClientSide` 를 가능하면 사용하세요.

### `FMLEnvironment#dist` 와 `@OnlyIn`

`FMLEnvironment#dist` 는 현재 코드가 실행되고 있는 **물리** 사이드를 저장하고 있습니다. 이 값은 프로그램이 시작될 때 결정되기 때문에 짐작하지 않고 확실한 값을 반환합니다. 그러나 이를 실제로 사용하는 경우는 드뭅니다.

메서드나 필드에 `@OnlyIn(Dist)` 어노테이션을 사용하면, 게임이 어노테이션에 전달된 **물리** 사이드에서 실행되고 있지 않다면, 이 멤버들이 불러와지는 과정에서 정의 자체가 아예 제거되어야 함을 나타냅니다. 일반적으로 디컴파일된 마인크래프트 코드에서 이 어노테이션이 자주 이용되는데, 이는 모장에서 난독화를 진행하며 제거한 메서드들을 나타내는데 쓰입니다. 이 어노테이션을 직접 사용할 이유는 **아예 없으며**, 대신 `DistExecutor` 또는 `FMLEnviroment#dist` 를 사용하세요.

자주하는 실수들
---------------

### 논리 사이드 가로지르기

한쪽 논리 사이드에서 반대쪽으로 정보를 보내고 싶으시다면, **언제나** 네트워크 패킷을 사용하여 전달하도록 하세요. 사실 싱글 플레이에서 사이드를 가로질러 정보를 직접적으로 보내는 것이 좋아보일 수는 있습니다.

계다가 이는 많은 모드 개발자들이 정적 필드를 사용해서 하는 것입니다. 그러나 싱글 플레이에서는 논리 서버와 논리 클라이언트가 같은 JVM 에서 실행되기 때문에, 스레드 2개가 정적 필드 하나를 읽고 쓰는 것은 경쟁 상태를 유발할 수 있으며 스레드와 관련된 여러 고질적인 문제들을 일으킬 수 있습니다.

또, `Minecraft` 클래스와 같이 물리 클라이언트 전용 코드를, 양쪽 사이드에서 실행되거나, 또는 논리 서버에서 접근하는 것 또한 사이드를 가로지르는 것입니다. 이는 물리 클라이언트에서만 디버그를 하는 초보자 분들이 놓치기 쉬운 것입니다. 물리 클라이언트에서 작동은 되겠지만 물리 서버에서는 바로 튕깁니다.


한쪽 사이드 전용 모드 만들기
----------------------

최근 출시된 마인크래프트 버전에서 포지는 "sideness" 속성을 mods.toml 에서 제거하였습니다. 다시 말해서 모드를 물리 서버에 설치하든 물리 클라이언트에 설치하든 작동은 해야  한다는 것입니다. 그렇기에 한쪽 사이드만을 위한 모드를 만드신다면 이벤트 핸들러를 직접적으로 등록하기 보단 `DistExecutor#safeRunWhenOn` 또는 `DistExecutor#unsafeRunWhenOn` 를 사용하여 등록하여야 합니다. 그렇게 하여 만약 모드가 잘못된 사이드에 설치되었다면 존재는 하지만 아무것도 안하도록 하는 것이지요. 이러한 모드들은 블록이나 엔티티, 아이템 등을 등록하면 안됩니다, 왜냐하면 이러한 것들은 반대쪽 사이드에도 존재해야 하기 때문입니다.

추가적으로 한쪽 사이드 전용 모드를 만드신다면 그 모드가 없는 유저가 서버에 들어올 수 있도록 하는 것이 좋습니다. 그렇기에 `IExtensionPoint$DisplayTest` extension point 를 오버라이드하여, 서버에 접속하기 위해 모드가 요구되지 않도록 하고 호환되지 않음으로 표시되지 않도록 할 수 있습니다. 이를 오버라이드 하기 위해서는 모드의 생성자에 다음과 같은 구문을 사용하시면 됩니다:
```
// 모드가 없어도 클라이언트에서 서버가 호환되지 않는다고 표시하지 않도록 하세요.
ModLoadingContext.get().registerExtensionPoint(ExtensionPoint.DISPLAYTEST, () -> Pair.of(() -> FMLNetworkConstants.IGNORESERVERONLY, (a, b) -> true));
```
이는 클라이언트가 서버 버전이 없어도 무시하도록 하고, 서버는 클라이언트에 모드 설치를 요구하지 않도록 합니다. 그렇기에 위 코드는 서버 전용 또는 클라이언트 전용 모드 둘다에서 작동합니다.

[invokedynamic]: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokedynamic
[dist]: #fmlenvironmentdist--onlyin
[DistExecutor이슈페이지]: https://github.com/MinecraftForge/MinecraftForge/issues/8008